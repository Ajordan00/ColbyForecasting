---
title: "My Second Species"
output: github_document
---
The first step of any good script is to setup the environment.

```{r setup}
source("setup.R")
```

Before we think about a second species we must read in the Brickman data. 

```{r read_brickman}
db = brickman_database() |>
  dplyr::filter(scenario == "PRESENT", interval == "mon")
present = read_brickman(add = c("depth"))
```

Looking at species that interact with the North Atlantic Scallop (Placopecten magellanicus), the most apparent is the Northern Sea Star (Asterias rubens), the most common predator of the scallops. Lets get the data from OBIS. 

Note: I chose to remove the minimum_year restriction simply to get enough data to populate each month (keep this in mind when interpreting results)

```{r read_observations}
fetch_obis("Asterias rubens")
obs = read_observations(scientificname = "Asterias rubens", minimum_year = 0)
table(obs$month)
```

Now that we have filtered species data for the Starfish, lets weigh the observations before populating background points.

```{r weigh_observations}

db = brickman_database() |>
  filter(scenario == "STATIC", var == "mask")
mask = read_brickman(db)

bias_map = rasterize_point_density(obs, mask)

```

Next lets actually populate those background points

```{r background_points}
all_counts = count(st_drop_geometry(obs), month)
nback_avg = mean(all_counts$n) |>
  round()
nback_avg

obsbkg = sapply(month.abb,
    function(mon){ 
      sample_background(obs |> filter(month == mon), # <- just this month
                       bias_map,
                       method = "bias",  # <-- it needs to know it's a bias map
                       return_pres = TRUE, # <-- give me the obs back, too
                       n = nback_avg) |>   # <-- how many points
        mutate(month = mon, .before = 1)
    }, simplify = FALSE) |>
  bind_rows() |>
  mutate(month = factor(month, levels = month.abb))
obsbkg 
```

Lets take a look at our presence vs background points, and then save the model_input. 

```{r check_and_save_model_input}
coast = read_coastline()

ggplot() +
  geom_sf(data = obsbkg, 
          mapping = aes(col = class),
          alpha =  0.4, shape = "circle small", size = 1) +
  geom_sf(data = coast, col = "orange")  + 
  labs(x = "Longitude", y = "Latitude", title = "All") +   
  theme_bw() +  # <- make a simple white background
  scale_fill_okabe_ito() +  # <-- colorblind friendly for N Record
  facet_wrap(~month)

model_input = write_model_input(obsbkg, scientificname = "Asterias rubens")
```

Now lets get covariates sorted, and compare them between presence and background points

```{r covariates}
variables = extract_brickman(present, model_input, form = "wide")
variables = variables |>
  select(-.id) 
plot_pres_vs_bg(variables |> select(-month), "class")
```

From the plots we can tell that mixed layer depth, sea surface temperature, and bottom temperature are the most telling variables. Now lets save this config!

```{r config}
cfg = list(
  version = "v1",
  scientificname = "Asterias rubens",
  background = "average of observations per month",
  keep_vars =  keep)

ok = make_path(data_path("models")) # make a directory for models
write_configuration(cfg)  

write_model_input(variables, scientificname = "Asterias rubens", version = "v1")
```

Success!

Now time to build and run a model.

```{r build_model}
cfg = read_configuration(scientificname = "Asterias rubens", version = "v1")
model_input = read_model_input(scientificname = "Asterias rubens", 
                               version = "v1",
                               log_me = c("depth", "Xbtm")) |>
  dplyr::mutate(month = month_as_number(.data$month)) |>
  select(all_of(c("class", cfg$keep)))

model_input_split = spatial_initial_split(model_input, 
                        prop = 1 / 5,     # 20% for testing
                        strategy = spatial_block_cv) # see ?spatial_block_cv
model_input_split

tr_data = training(model_input_split)
cv_tr_data <- spatial_block_cv(tr_data,
  v = 5,     
  cellsize = grid_cellsize(model_input),
  offset = grid_offset(model_input) + 0.00001
)

one_row_of_training_data = dplyr::slice(tr_data,1)
rec = recipe(one_row_of_training_data, formula = class ~ .)

wflow = workflow_set(
  
  preproc = list(default = rec), # not much happening in our preprocessor
  
  models = list(                 # but we have 4 models to add
    
      # very simple - nothing to tune
      glm = logistic_reg(
          mode = "classification") |>
        set_engine("glm")
      
  )
)

metrics = sdm_metric_set(yardstick::accuracy)

wflow <- wflow |>
  workflow_map("tune_grid",
    resamples = cv_tr_data, 
    grid = 3,
    metrics = metrics, 
    verbose = TRUE)

model_fits = workflowset_selectomatic(wflow, model_input_split,
                                  filename = "Asterias_rubens-v1-model_fits",
                                  path = data_path("models"))

model_fit_metrics(model_fits)
```

Note: I used glm only to allow for quick run time

Now that we have a "functional" model lets look at how successful it is.

```{r model_fit_analysis}
model_fit_confmat(model_fits)
model_fit_roc_auc(model_fits)
model_fit_pdp(model_fits, wid = "default_glm", title = "Linear Regression")
```

Looks pretty bad... oh well science must continue!

Lets get to forecasting. First gotta load some useful things.

```{r load_stuff}
cfg = read_configuration(scientificname = "Asterias rubens",
                         version = "v1", 
                         path = data_path("models"))
db = brickman_database()
db = brickman_database()
present_conditions = read_brickman(db |> filter(scenario == "PRESENT", 
                                                interval == "mon"),
                       add = c("depth", "month")) |>
  select(all_of(cfg$keep_vars))

model_fits = read_model_fit(filename = "Asterias_rubens-v1-model_fits")

```

Now lets get a look at how the sea stars are doing.

```{r nowcast}
nowcast = predict_stars(model_fits, present_conditions)
pa_nowcast = threshold_prediction(nowcast)
plot_prediction(nowcast['default_glm'])
plot_prediction(pa_nowcast['default_glm'])
```

Interesting... honestly as expected considering the model never guesses background during testing...

Now lets see their future.

```{r future}
covars_rcp85_2075 = read_brickman(db |> filter(scenario == "RCP85", 
                                               year == 2075, 
                                               interval == "mon"),
                                  add = c("depth", "month")) |>
  select(all_of(cfg$keep_vars))

plot_prediction(forecast_2075['default_glm'])

```

Uh oh... the model predicts total extinction by 2075. These results are certainly rough to see, but lucky for the sea stars I think the dataset was quite rough to begin with, and glm certainly is not the most accurate prediction model. Anywho there is my attempt at making a quick and easy prediction model for sea stars in the Gulf of Maine. Key note, I urge nobody to take this forecast seriously, and I wish the best for the lovely Asterias Rubens.
